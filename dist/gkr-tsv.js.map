{"version":3,"sources":["../src/gkr-tsv.js"],"names":["outputObj","output","numCols","Math","max","map","line","length","paddedOutput","concat","Array","fill","close","outputFile","open","outputPath","write","requiredHeader","colHeaders","join","saveOutput","argv","demandCommand","option","alias","describe","type","nargs","default","date","getFullYear","getMonth","slice","getDate","Date","strict","_","inputFile","readFile","toString","Error","split","filter","dropTrailingBlanks","shift","curCol","findIndex","d","push","forEach","curVal","idx","parsedMaxPages","parseInt","isNaN","err","retries","includes","console","log","gkr","getRanking","searchTerms","urlRegex","maxPagesToSearch","result","RegexFound","ranking","NotFound","nrResSearched","ReachedMaxPages","Err","maxRetries","waitAfterError","resolveAfterDelay","escapeErr","String","minRequestDelay","main","mainWrapper","install","arr","arrRevd","reverse","replace","module","exports"],"mappings":"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","file":"gkr-tsv.js","sourcesContent":["\n\n//  Copyright 2017 Jonathan Ganc\n//\n//  This file is part of googlekeywordranking.\n//\n//  googlekeywordranking is free software: you can redistribute it and/or\n//  modify it under the terms of the GNU General Public License as\n//  published by the Free Software Foundation, either version 3 of the\n//  License, or (at your option) any later version.\n//\n//  Foobar is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with Foobar.  If not, see <http://www.gnu.org/licenses/>.\n\n\n//  Input is a tsv file..\n//  The first three columns specify the terms to search for (described\n//    below).  The remaining columns give the ranking on a particular date.\n//  The first row is a heading row. The first three columns of the first\n//    row are ignored. The next columns are dates in the format YYYY/MM/DD,\n//    indicating the date for the rankings in that column.\n//\n//  The settings: The first three columns are\n//   1) search term: what is looked up in Google, e.g. 'sinus boca raton'\n//   2) url regex: a regex for what is searched for in the url,\n//      e.g. 'danielgancmd\\.com'\n//   3) max result pages to download\n//  If a line has only one or two columns, the previous value of\n//    'search term', 'max result pages' is used. Thus, the first line must\n//    have three columns at least.\n//\n//  If the program is rerun for an already existing date, only blank or\n//    error columns are changed.\n//\n//  Result column explanations\n//    [ranking]           - the term's ranking\n//    N[results searched] - the term was not found after searching\n//                          through all search results returned.\n//                          [results searched] terms were given.\n//    M[results searched] - the term was not found after loading the\n//                          maximum allowed number of pages.\n//                          [results searched] terms were searched.\n//    E[error object]     - an error occurred. Following the 'E' will be\n//                          the error message\n\n//  usage:\n//    gkr-tsv [-d|--date DATE] inputfile [outputfile]\n//\n//  If no outputfile is given, the inputfile is edited in place.\n//\n//  Usually, the current date is used. However, the date option allows\n//    different text (it need not even be a date) to be used for the date\n//    row.\n\nimport fs from 'mz/fs';\nimport yargs from 'yargs';\nimport * as gkr from './googlekeywordranking.js';\nimport SourceMapSupport from 'source-map-support';\n\nSourceMapSupport.install();\n\nconst requiredHeader = 'search term\\turl regex\\tmax result pages';\n\n// how long to wait to retry after an error\nconst waitAfterError = 180000;\nconst maxRetries = 3;\n\n//  Drop the trailing blank elements (i.e. '') in ARR\n//  This is not destructive.\nfunction dropTrailingBlanks(arr) {\n  // split on tabs and drop trailing blanks\n  const arrRevd = arr.slice().reverse();\n  while (arrRevd[0] === '') {\n    arrRevd.shift();\n  }\n  return arrRevd.reverse();\n}\n\n//  save the output array to OUTPUTOBJ non-destructively, padding each line\n//  to have the same of lines.\n//\n//  OUTPUTOBJ is an object { outputFile, outputPath, colHeaders }.\n//\n//  It is assumed that OUTPUTFILE is an open file descriptor to OUTPUTPATH.\n//  It will be closed and reopened over the course of this function.\n//  We do this to try and  keep OUTPUTPATH always in use.\n//  COLHEADERS is save to first row after REQUIREDHEADER\nasync function saveOutput(outputObj, output) {\n  const numCols = Math.max(...output.map( (line) => line.length ));\n  \n  const paddedOutput = output.map(\n    (line) => line.concat(Array(numCols - line.length).fill('')));\n\n  await fs.close(outputObj.outputFile);\n  outputObj.outputFile = await fs.open(outputObj.outputPath, 'w');\n  await fs.write(outputObj.outputFile,\n                 // eslint-disable-next-line prefer-template\n                 requiredHeader + '\\t'\n                 + outputObj.colHeaders.join('\\t') + '\\n'\n                 + paddedOutput.map(\n                   (line) => (line).join('\\t')).join('\\n') + '\\n');\n}\n\n// return an escaped version of ERR for TSV files\n// replace TAB, RET with \\t, \\n. Not perfect but OK\nfunction escapeErr(err) {\n  return err.replace(/\\t/, '\\\\t').replace(/\\n/, '\\\\n');\n}\n\nasync function main() {\n  // parse arguments\n  const argv = yargs\n        .demandCommand(\n          1, 2,\n          'Please provide an input file', 'Too many commands given')\n        .option('d', {\n          alias: 'date',\n          describe:\n          'Text used in date column.'\n            + ' By default, it will be the current date in the'\n            + ' format YYYY/MM/DD',\n          type: 'string',\n          nargs: 1,\n          default: (\n            (date) => \n              /* eslint-disable prefer-template */\n              date.getFullYear()\n              + '/' + ('0' + (date.getMonth() + 1)).slice(-2)\n              + '/' + ('0' + date.getDate()).slice(-2))(new Date()),\n          /* eslint-enable prefer-template */\n        })\n        .strict()\n        .argv;\n\n  const inputFile = await fs.open(argv._[0], 'r');\n  // the processed input is the output\n  let output = (await fs.readFile(inputFile)).toString();\n  await fs.close(inputFile);\n\n  //  see saveOutput for more about outputObj\n  let outputObj = {};\n  if (argv._.length === 1) {\n    outputObj.outputPath = argv._[0];\n  } else {\n    outputObj.outputPath = argv._[1];\n  }\n\n  // check that output has required header\n  if (output.slice(0, requiredHeader.length) !== requiredHeader) {\n    throw new Error(\n      `${outputObj.outputPath} missing expected header: ${requiredHeader}`);\n  }\n\n  // split output\n  output = output.toString().split('\\n')\n    .filter( (line) => line !== '')\n    .map( (line) => dropTrailingBlanks(line.split('\\t')) );\n  \n  //  first row is a header row.\n  //  any columns after the first three represent the col headers\n  const colHeaders = outputObj.colHeaders = output.shift().slice(3);\n\n  let curCol = colHeaders.findIndex( (date) => date === argv.d);\n  // date not found\n  if (curCol === -1) {\n    colHeaders.push(argv.d);\n    curCol = colHeaders.length - 1;\n  }\n  // move past 3 header rows\n  curCol += 3;\n\n  //  Add 'to search for' to all lines if not present\n  //\n  //  First line must have 'url regex', 'max pages' defined\n  if (output[0].length < 3) {\n    throw new Error('The first settings line must have at least 3 columns');\n  }\n\n  //  open output and write what we have\n  outputObj.outputFile = await fs.open(outputObj.outputPath, 'w');\n  await saveOutput(outputObj, output);\n\n  //  Fill in any blank settings\n  output.forEach(\n    (curVal, idx) => {\n      if (curVal.length === 1) {\n        curVal.push(output[idx - 1][1]);\n      }\n      if (curVal.length === 2) {\n        curVal.push(output[idx - 1][2]);\n      }\n      const parsedMaxPages = parseInt(curVal[2]);\n      if (isNaN(parsedMaxPages)) {\n        throw new Error(\n          `request ${idx} -- with search term '${curVal[0]}' --`\n            + ` has a non-parseable max pages: ${curVal[2]}`);\n      }\n      curVal[2] = parsedMaxPages;\n    });\n\n  let err = null;\n  try {\n    let idx = 0;\n    let retries = 0;\n    // the code for searching for terms\n    while (idx < output.length) {\n      const line = output[idx];\n      if (!line[curCol] || ['E', 'C'].includes(line[curCol][0])) {\n        console.log(`looking up: ${line.slice(0, 3)}`);\n        const result = await gkr.getRanking({\n          searchTerms: line[0],\n          urlRegex: line[1],\n          maxPagesToSearch: line[2],\n        });\n        /* eslint-disable prefer-template */\n        if (result instanceof gkr.RegexFound) {\n          // add new elements\n          line[curCol] = result.ranking;\n        } else if (result instanceof gkr.NotFound) {\n          // add new elements\n          line[curCol] = 'N' + result.nrResSearched;\n        } else if (result instanceof gkr.ReachedMaxPages) {\n          // add new elements\n          line[curCol] = 'M' + result.nrResSearched;\n        } else if (result instanceof gkr.Err) {\n          //  retry after delay unless we've exceeded max retries\n          retries += 1;\n          if (retries < maxRetries) {\n            console.log(\n              `#${retries}: waiting ${waitAfterError/1000} seconds`\n              + ` before retrying because of error: ${result.err}`);\n            await gkr.resolveAfterDelay(waitAfterError);\n            continue;\n          }\n          line[curCol] = 'E' + escapeErr(String(result.err));\n        } else {\n          line[curCol] = 'EUnknown result code.';\n        }\n        /* eslint-enable prefer-template */\n\n        // save output\n        await saveOutput(outputObj, output);\n        if (line[curCol][0] === 'E') {\n          throw new Error(\n            `googlekeywordranking error on line ${idx}:`\n              + ` ${line[curCol].slice(1)}`);\n        }\n        \n        // if we are not on the last one, delay before moving on\n        if (idx + 1 < output.length) {\n          await gkr.resolveAfterDelay(gkr.minRequestDelay);\n        }\n      }\n      // move to next line\n      retries = 0;\n      idx += 1;\n    }\n  } catch (e) {\n    err = e;\n  } finally {\n    await fs.close(outputObj.outputFile);\n  }\n\n  if (err) throw err;\n}\n\n// a wrapper to catch errors\nasync function mainWrapper() {\n  try {\n    await main();\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nmodule.exports = mainWrapper;\n\n// try {\n//   main();\n// } catch (err) {\n//   console.log('hi');\n//   throw new Error('the error' + String(err));\n// }\n"]}