{"version":3,"sources":["../src/googlekeywordranking.js"],"names":["input","requestOpts","urlRegex","maxPagesToSearch","Error","defaults","pageNr","curResNr","reqContext","_debugHtmlArray","Object","assign","response","curTime","Date","lastRequestTime","resolveAfterDelay","minRequestDelay","getTime","processPageInput","body","pop","request","href","$page","load","reqUrl","stats","getStats","each","$res","attr","find","text","replace","match","RegexFound","next","resolve","ReachedMaxPages","processPage","makeReqOptsForUrl","NotFound","Result","setStats","searchTerms","result","makeReqestOptsForTerms","Err","getRanking","arr","failed","Promise","all","map","searchOpts","Cancelled","getRankingArr","genErrMsg","install","config","require","e","code","ResStats","nrResults","ranking","url","nrResSearched","nextPage","err","toWait","setTimeout","Math","max","pageStats","parseInt","configReqOpts","reqOpts","uri","jar","simple","resolveWithFullResponse","qsOpts","num","qs","terms","queryString","stringify","q","format","msgStart","msgEnd","StatusCodeError","statusCode","error","RequestError","message","stack","msgMiddle","i"],"mappings":"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","file":"googlekeywordranking.js","sourcesContent":["//  Copyright 2017 Jonathan Ganc\n//\n//  This file is part of googlekeywordranking.\n//\n//  googlekeywordranking is free software: you can redistribute it and/or\n//  modify it under the terms of the GNU General Public License as\n//  published by the Free Software Foundation, either version 3 of the\n//  License, or (at your option) any later version.\n//\n//  Foobar is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with Foobar.  If not, see <http://www.gnu.org/licenses/>.\n\nimport urlLib from 'url';\nimport request from 'request-promise-native';\nimport requestErrors from 'request-promise-native/errors';\nimport SourceMapSupport from 'source-map-support';\nimport qs from 'qs';\nimport $ from 'cheerio';\nimport nconf from 'nconf';\n\nSourceMapSupport.install();\n\n// the config file\nlet config;\ntry {\n  config = require('../config');\n} catch (e) {\n  if (e.code === 'MODULE_NOT_FOUND') {\n    config = {};\n  } else {\n    throw e;\n  }\n}\n\n// request.debug = true;\n \n//  minimum delay between requests in ms\nexport const minRequestDelay = 10000;\n// exports.minRequestDelay = minRequestDelay;\n// const minRequestDelay = 1;\n\n//////////////////////////////////////////////////////////////////////////\n//  DEFINE CLASSES\n\n//  stats about the result\nexport class ResStats {\n  constructor(nrResults) {\n    // number of results\n    this.nrResults = nrResults;\n  }\n}\n\n//  a class to wrap either the result or the reason for failure\n//\n//  we set nrResults on the first page (for some reason)\nexport class Result {\n  constructor() {\n    this.stats = null;\n  }\n\n  // function for adding stats\n  setStats(stats) {\n    this.stats = stats;\n  }\n}\n\nexport class RegexFound extends Result {\n  constructor(ranking, url) {\n    super();\n    this.ranking = ranking;\n    this.url = url;\n  }\n}\n\n// reaches end of results and regex still not found\n// nrResSearched: number of results searched\nexport class NotFound extends Result {\n  constructor(nrResSearched) {\n    super();\n    this.nrResSearched = nrResSearched;\n  }\n}\n\n//  Meaning: there were more links but we were forbidden from searching them\n//  due to maxPagesToSearch\n//  nextPage: link to the next page\nexport class ReachedMaxPages extends Result {\n  constructor(nextPage, nrResSearched) {\n    super();\n    this.nextPage = nextPage;\n    this.nrResSearched = nrResSearched;\n  }\n}\n\n// some kind of error\nexport class Err extends Result {\n  constructor(err) {\n    super();\n    this.err = err;\n  }\n}\n\n// cancelled because of previous error\nexport class Cancelled extends Result {\n}\n\n//  FINISHED WITH CLASSES\n///////////////////////////////////////////////////////////////////////////\n\n\n// time of last request\nlet lastRequestTime;\n\n// returns a promise that resolves after toWait milliseconds\nexport function resolveAfterDelay(toWait) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve();\n    }, Math.max(0, toWait));\n  });\n}\n\n//  process the page at URL, ultimately returning either the position of the\n//  first url matching urlRegexToFind or null if maxPagesToSearch has been\n//  reached\n//\n//  return a Results object, indicating the result\n//\n//  Settings are given as key-value pairs in the object passed in\n//\n//  The following settings are required\n//   requestOpts:  options for the next request\n//   urlRegex:  regex to find on the page\n//   maxPagesToSearch: maximum number of pages to search. set to -1 to\n//     disable.\n//\n//  The following settings are used for recursion and need not be\n//  originally passed:\n//\n//   pageNr:  page number that url will be\n//   curResNr:  current result number the page will start at\n//\n//  The following setting(s) is purely for debugging:\n//\n//   _debugHtmlArray: for debugging, an array of html files can be passed\n//     here instead. instead of actually retrieving the next page via http,\n//     the next page will be popped off the array (and the remaining\n//     elements will be passed along to the next calling of processPage, if\n//     necessary). Note that an error will occur if the search term\n//     isn't found before the minimum of maxPagesToSearch and the length of\n//     _debugHtmlArray\nasync function processPage(input) {\n\n  if (!(typeof input === 'object'\n         && input.requestOpts && input.urlRegex && input.maxPagesToSearch)) {\n    throw new Error('processPage called without needed options');\n  }\n\n  const defaults = {\n    pageNr: 1,\n    curResNr: 0,\n    reqContext: null,\n    _debugHtmlArray: null,\n  };\n\n  let { requestOpts, urlRegex, maxPagesToSearch,\n       pageNr, curResNr, _debugHtmlArray}\n      = Object.assign(defaults, input);\n\n  // console.log(\n  //   '{ requestOpts, urlRegex, maxPagesToSearch,'\n  //     + ' pageNr, curResNr, _debugHtmlArray}:',\n  //   { requestOpts, urlRegex, maxPagesToSearch,\n  //     pageNr, curResNr, _debugHtmlArray});\n\n  let response;\n  if (! _debugHtmlArray) {\n    try {\n      const curTime = new Date();\n      if (lastRequestTime) {\n        await resolveAfterDelay(\n          minRequestDelay\n            - (curTime.getTime() - lastRequestTime.getTime()));\n      }\n      lastRequestTime = new Date();\n      response = await request(requestOpts);\n    } catch (e) {\n      // add current input to error and then rethrow\n      e.processPageInput = input;\n      throw (e);\n    }\n  } else {\n    // we simulate enough of a response object for our purposes\n    response = {\n      body: _debugHtmlArray.pop(),\n      request: {\n        href: `_debugHtmlArray page ${pageNr}`\n      }\n    };\n  }\n\n  const $page = $.load(response.body);\n  const reqUrl = response.request.href;\n\n  //  get stats if we are on the first page\n  let stats;\n  if (pageNr === 1) stats = getStats($page);\n\n  try {\n    $page('.g').each(/* @this elt */function() {\n      const $res = $(this);\n      //  it turns out that we only want the results which have the class 'g'\n      //  and only the class 'g'\n      if (! ($res.attr('class') === 'g' && ! $res.attr('id'))) {\n        return;\n      }\n\n      curResNr++;\n      if ($res.find('cite').text().replace(/›.*/, '').match(urlRegex)) {\n        throw new RegexFound(curResNr, reqUrl);\n      }\n    });\n    \n    //  we've searched through all links on this page and not found result\n\n    // next, let us check for more page links\n    let next = $page('#pnnext').attr('href');\n    if (next) {\n      next = urlLib.resolve(reqUrl, next);\n      \n      //  if we are not allowed to search more pages, notify that\n      if (pageNr + 1 > maxPagesToSearch) {\n        throw new ReachedMaxPages(next, curResNr);\n      }\n      \n      // otherwise, proceed to next page.\n      // we rethrow the result so that we can ad stats if needed\n      throw await processPage({\n        requestOpts: makeReqOptsForUrl(next),\n        urlRegex,\n        maxPagesToSearch,\n        pageNr: pageNr + 1,\n        curResNr,\n        _debugHtmlArray\n      });\n    } else {\n      // no more links\n      throw new NotFound(curResNr);\n    }\n    // eslint-disable-next-line no-unreachable\n    throw new Error('Should never reach this point');\n  } catch (e) {\n    // if we caught a result, pass it along\n    if (e instanceof Result) {\n      if (pageNr === 1) e.setStats(stats);\n      return e;\n    }\n    // rethrow other errors, adding options and curResNr\n    e.processPageInput = input;\n    e.curResNr = curResNr;\n    throw e;\n  }\n}\n\nfunction getStats($page) {\n\n  const pageStats = new ResStats();\n  // find num of results\n  let match = $page('#resultStats').text().match(/ ([0-9,]+) results/);\n  if (!match) {\n    throw new Error('Format of results stats not as expected');\n  }\n\n  pageStats.nrResults = parseInt(match[1].replace(/,/, ''));\n  return pageStats;\n}\n\n// make request options for url\nfunction makeReqOptsForUrl(url) {\n  //  note that {...obj} clones obj\n  const configReqOpts = config.reqOpts ? {...config.reqOpts} : {};\n  const reqOpts = Object.assign(configReqOpts, {\n    uri: url,\n    jar: true,  //  remember cookies!\n    //  statuses other than 2xx reject the promise (this is actually\n    //  true by default, anyway)\n    simple: true,\n    //  resolve promise with full response since we use transform2xxOnly\n    //  and !simple, this will actually only apply to promise rejections\n    resolveWithFullResponse: true,\n  });\n  const qsOpts = { num: 100 };\n  // let us add to/replace, rather than completely overwrite, qs opts\n  if (reqOpts.qs) {\n    Object.assign(reqOpts.qs, qsOpts);\n  } else {\n    reqOpts.qs = qsOpts;\n  }\n  // console.log('reqOpts:', reqOpts)\n  return reqOpts;\n}\n\n// make request options for terms\nfunction makeReqestOptsForTerms(terms) {\n  const queryString = qs.stringify({\n    q: terms\n    // the format parameter makes ' ' into '+' instead of '%20'\n  }, {format: 'RFC1738'});\n  const url = `https://www.google.com/search?${queryString}`;\n  return makeReqOptsForUrl(url);\n}\n\n// return an appropriate error message for an error err thrown by\n// googlekeywordranking\nexport function genErrMsg(err) {\n  let msgStart;  // start of error message\n  let msgEnd;    // end of error message\n\n  if (err instanceof requestErrors.StatusCodeError) {\n    msgStart = `StatusCodeError error: ${err.statusCode}`;\n    msgEnd = `\\n*Content*\\n${err.error}`;\n  } else if (err instanceof requestErrors.RequestError) {\n    msgStart = `Request error: ${err.error.message}`;\n    msgEnd = `\\n*With stack*\\n${err.error.stack}`;\n  }\n\n  let msgMiddle; // middle part of message\n  //  I think processPageInput should always be set, but just in case\n  if (err.processPageInput) {\n    const i = err.processPageInput;\n    msgMiddle = `While retrieving: ${i.url}`\n      + `\\nPage nr: ${i.pageNr}`\n      + `\\nResult nr. on page: ${i.curResNr - i.pageNr}`;\n  }\n\n  return (\n    (msgStart ? `$(msgStart)\\n` : '') + msgMiddle\n      + (msgEnd ? `\\n$(msgEnd)` : ''));\n};\n\n// returns a result object indicating where the term was found\nexport async function getRanking({\n  searchTerms, urlRegex,\n  maxPagesToSearch = 4, _debugHtmlArray = null}) {\n  let result;\n  try {\n    result = \n      await processPage({\n        requestOpts: makeReqestOptsForTerms(searchTerms),\n        urlRegex,\n        maxPagesToSearch,\n        _debugHtmlArray\n      });\n  } catch (err) {\n    result = new Err(err);\n  }\n  return result;\n}\n\n// takes an array of objects, passing them each to getRanking. If any of\n// them returns Error, all subsequent requests return Cancelled\nexport async function getRankingArr(arr) {\n  // indicates if any of the attempts so far have failed\n  let failed = false;\n  return Promise.all(arr.map(async (searchOpts) => {\n    if (failed) {\n      return new Cancelled();\n    }\n    const result = await getRanking(searchOpts);\n    if (result instanceof Err) {\n      failed = true;\n    }\n    return result;\n  }));\n};\n"]}